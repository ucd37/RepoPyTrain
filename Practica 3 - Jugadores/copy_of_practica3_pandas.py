# -*- coding: utf-8 -*-
"""Copy of Practica3_Pandas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vzXk2tINBkMOl5iePQtImfA-H54_cd4i

# Analizando las estadísticas de jugadores de futbol con Pandas

![FIFA](https://upload.wikimedia.org/wikipedia/commons/thumb/a/aa/FIFA_logo_without_slogan.svg/1200px-FIFA_logo_without_slogan.svg.png)

En esta notebook, utilizarás Pandas para analizar datos de jugadores de futbol (soccer). Los datos se encuentran en forma tabular e incluyen información relevante de jugadores de futbol de todo el mundo.

---


Cada fila en el conjunto de datos contiene información sobre el jugador:
* Información personal: Nombre, nacionalidad, , edad, altura, peso y pierna preferida al jugar.
* Información como jugador: Nombre del equipo en el que juega (Club), número de playera, posición en el campo (abreviada), valor comercial y salario.
* Información sobre sus habilidades como jugador (0-100): Overall, Potential, Shooting, Defense, Passing, Physical, Control, Mental y GoalKeeping.


Durante la notebook llevarás a cabo tareas de tratamiento y análisis exploratorio de datos comunmente realizadas. Buscarás información que podría resultar útil para las organizaciones.



---



Recuerda que puedes acudir a la [documentación de Pandas](https://pandas.pydata.org/pandas-docs/stable/reference/index.html) o a la notebook de Pandas del diplomado en ciencia de datos.

Primero, importa Pandas en tu notebook:
"""

# pandas usando el alias pd
import pandas as pd

"""Ejecuta la siguiente celda para cargar el conjunto de datos desde el repositorio en github a la máquina en colab.

curl (Client URL) transifere datos desde-hacia un servidor. Descarga archivos desde internet.

! indica que el comando se ejecuta en la terminal del sistema (no es codigo Puthon). Se usa en Jupyter Notebook/Colab para correr comandos de shell.

--remote-name o -0, guarda el archivo descargado con el missmo nombre que tiene en el servidor remoto (players.csv)

\ inidca que el comando continua en la siguiente linea
"""

# Fetch the dataset using the raw GitHub URL.
!curl --remote-name \
     -H 'Accept: application/vnd.github.v3.raw' \
     --location https://raw.githubusercontent.com/DCDPUAEM/DCDP/main/01%20Programaci%C3%B3n%20en%20Python/data/fifa/players.csv

"""Veamos las primeras líneas del archivo usando un comando de linux en la celda de colab:"""

# Muestra las primeras 5 lineas del archivo incuyendo el encabezado
!head -n 5 players.csv
# "Cuenta el total de lineas del archivo"
!wc -l players.csv
# "Muetsra las ultimas 5 lineas del archivo"
!tail -n 5 players.csv

# Notese, que los valores estan separado por comas, lo cual sera util para definir mas tarde el caracter para separar los valores.

"""## Carga el conjunto de datos FIFA usando pandas"""

# leer el dataframe usando read_csv.
# "Sep" define el tipo de carácter para "SEPARAR" los valores.
# Si el archivo no tiene encabezado, header=None, creara uno generico numerado (0,1,2,...)
fifa_df = pd.read_csv("players.csv", sep=',', header=0)
# mostrar los primeros elementos con head
fifa_df.head()

fifa_df.info()

"""## Características del dataset

¿Qué tipos de datos contiene nuestro dataframe?
"""

# Se usa el bucle "For" conbinado con la función "zip()" para iterar simultáneamente sobre los "nombres de las columnas" y sus "tipos de datos"
# "fifa_df.columns" devuelve un array con los nombres de las columnas del DataFrame, ejemplo: ['Nombre', 'Edad', 'Pais']
# "fifa_df.dtypes" devuelve una serie con los tipos de datos de cada columna, ejemplo: Nombre--> Objeto, Edad --> int64...
# zip() combina los dos iterables (Columnas y dtypes) en pares ordenados. Ejemplo: [('Nombre', dtyppe('0')), ('Edad', dtype('int64')), ('Paris', dtype('0'))]

for name, t in zip(fifa_df.columns, fifa_df.dtypes): # otra alternativa seria: for name, t in fifa_df.dtypes.items():
  print(name, t)

"""¿Qué tamaño tiene nuestro dataset?

Utiliza el método ```shape``` para conocer el número de filas y columnas en el dataframe.
"""

m,n = fifa_df.shape[0], fifa_df.shape[1]   # <completado>
print("Filas:", m)
print("Columnas:", n)

print("Otro metodo sería:")
m,n = fifa_df.shape
print(f"Filas: {m}, Columnas: {n}")

assert m == 18207 and n == 21, "Error en las dimensiones"

"""### Estadísticas generales del dataset.

Usa ```describre()``` para mostrar las estadísticas generales de las columnas numéricas en el dataframe.
"""

fifa_df.describe()

"""## Tratamiento de datos

### Datos faltantes

Antes de poder hacer transformaciones y operaciones en los datos, es importante identificar la posible existencia de datos faltantes. El método ```isna()``` de pandas, permite obtener un dataframe booleano que identifica entradas faltantes.

.isna() o.isnull() son lo mismo, devuelve un DataFrame desl mismo tamaño que t_df, donde cada celda contiene True si el valor original era NaN (nulo/missing) o Flase si el valor original NO era nulo.

.sum() sauma los valores True (considerados como 1 (NaN)) y False (como 0 (No Nulo)) a lo largo del eje axis=0 (columnas).

.to_frame() convierte el Series resultante en un DataFrame de una sola columna para facilitar operaciones posteriores (como transponer).

.T transpone el DataFrame, conviertiendo filas en columnas y viceversa.

Usémos ```isna()```, ```sum(axis=0)``` y ```to_frame().T``` para resumir el resultado de datos faltantes como un conteo por columnas:
"""

# Para saber el total de NaN en todo el DataFrame
total_nan = fifa_df.isna().sum().sum()
print(total_nan)

fifa_df.isna().sum(axis=0).to_frame().T

"""Una manera de tratar con datos faltantes, es eliminar las filas que contienen uno o más datos faltantes, dejando solo registros completos.

Ya que para nuestro conjunto de datos la cantidad de faltantes es mínima, podemos usar esta estrategia.

Completa la siguiente celda para eliminar filas (```axis=0```) que contengan algún dato faltante (```dropna```):
"""

fifa_df.columns

# fifa_df.columns
t_df = fifa_df.dropna(axis=0)  # <completado>

"""Verifica que no hay más datos faltantes:"""

empty_columns = t_df.isna().sum(axis=0).to_frame().T
empty_columns
print(empty_columns[empty_columns > 0]) # Para ver las columnas con Nulos

# Para saber cuantas filas habia antes de eliminar los NaN y cuantas filas despues.
print(f"Filas originales: {len(fifa_df)}, Filas despues de dropna: {len(t_df)}")

m,n = t_df.shape
print(f"Filas: {m}, Columnas: {n}")

assert empty_columns.values.sum() == 0, "Error, aun hay datos faltantes"

# Para saber el arreglo despues de su ajuste (t_df) vs el original (fifa_df)
t_df.shape, fifa_df.shape

"""Finalmente, reemplazar el dataframe original por el nuevo sin elementos faltantes."""

fifa_df = t_df

"""### Transformaciones

Las celdas fueron inferidas como tipo ```object``` por pandas. Algunas de éstas contienen datos numéricos que podrían ser útiles para el análisis.

Por ejemplo, las columnas ```Wage``` y ```Value``` contienen datos sobre el salario y el valor en el mercado de cada jugador. Ambas columnas contienen el signo de la moneda (€) al inicio y al final pueden contener la abreviación de cantidades (K miles, M millones).

Debemos realizar un tratamiento de datos en tales columnas para poder usarlas de manera numérica.

Primero, confirmemos que solo tenemos casos donde las cantidades terminan en K, M o sin abreviaturas. Usemos funciones de agregación.

Contemos las veces que aparecen los distintos caracteres al final de los registros en la columna ```Wage```:
"""

fifa_df[["Wage"]].groupby(fifa_df.Wage.str[-1]).count()

"""Contemos las veces que aparecen los distintos caracteres al final de los registros en la columna ```Value```:"""

fifa_df[["Value"]].groupby(fifa_df.Value.str[-1]).count()

def currency_to_numeric(currency):
  """
  La funcion recibe valores monetarios en un objeto de texto, los tranforma:
  1- Elimina el simbolo de la moneda al inicio de la cadena
  2- Extrae el caracter adicional al final de la cadena que indica el
     multiplo de la cantidad (abreviatura). No siempre hay un simbolo.
  3- Usa el valor para devolver la cantidad en numero (multiplica por el valor).
  Ej: 250K pasa a 250000
  ya que
  1K = 1000
  1M = 1000000
  Sin letra solo parte numerica
  """
  # el multiplo de K o M
  symbols = {"K": 1000, "M": 1000000}

  numeric = float(''.join([c for c in currency if c.isdigit() or c == '.']))


  # Elimina cualquier simbolo de moneda al inicio
  # currency = currency.strip("€$£") # Ajusta segun las monedas

  #Verifica si el ultimo caracter es un multiplicador (K o M)
  multiplier = symbols.get(currency[-1], 1)

  # Convierte la parte numerica a flotante y multiplica
  # numeric = float(currency[:-1]) * multiplier if multiplier != 1 else float(currency)

  return numeric * multiplier #<completado>

"""Prueba tu función:"""

print(currency_to_numeric("$20"))
print(currency_to_numeric("$5M"))
print(currency_to_numeric("$250"))

assert currency_to_numeric("$20") == 20.0 and currency_to_numeric("$50K") == 50*10.0**3 and currency_to_numeric("$10M") == 10*10.0**6, "Error"

"""Cambia las columnas ```Wage``` y ```Value``` a numéricos usando ```currency_to_numeric``` elemento por elemento con ```applymap```:"""

fifa_df[["Wage", "Value"]] = fifa_df[["Wage", "Value"]].map(currency_to_numeric) #<completado>
fifa_df.head()

"""### Suplementando la información

En el set de datos, tenemos una columna ```Position``` que indica la posición en la que el jugador se desempeña en el campo. Algo que podrás notar, es que originalmente la posición está de manera abreviada, si no conoces las abreviaturas, será complicado saber en qué posición juega cada jugador.


Para solucionar esto, usémos otro set de datos para cambiar de abreviatura a algo más descriptivo, pero manteniendo la abreviatura.

La siguiente imágen muestra las posiciónes más comunes en el campo:
![Posiciones de juego](https://raw.githubusercontent.com/jhermosillo/DIPLOMADO_CDP/main/01%20Programaci%C3%B3n%20en%20Python/images/SoccerFieldPositions.png)

Vamos a utilizar un nuevo set de datos que contiene la abreviatura de cada posición (```Abbreviation```) y su significado (```Full```).

Carga el archivo desde github a colab con la siguiente celda:
"""

# Fetch the dataset using the raw GitHub URL.
!curl --remote-name \
     -H 'Accept: application/vnd.github.v3.raw' \
     --location https://raw.githubusercontent.com/DCDPUAEM/DCDP/main/01%20Programaci%C3%B3n%20en%20Python/data/fifa/positions.csv

"""Ejecuta la siguiente celda para crear y ver el nuevo dataframe con los datos de las posiciones:"""

positions_df = pd.read_csv("positions.csv", header=0, skipinitialspace=True)
positions_df.head()

"""Utiliza el nuevo dataframe para actualizar la columna ```Position``` en el dataframe de jugadores por la posición descriptiva + abreviada.

Primero, debemos de *unir* ambos dataframes, ambos comparten una columna (pero tienen diferentes nombre) la posición abreviada.

Utiliza un método de pandas para unir el dataframe ```fifa_df``` con ```positions_df```.

*Tip: Queremos unir cada fila de la **izquierda** (cada jugador) con una sola fila de la **derecha** (su posición completa en el campo).*
"""

merged_df = fifa_df.merge(positions_df, left_on = "Position", right_on = "Abbreviation") # <rellena>

merged_df.head()

assert len(merged_df.columns) == 23, "Error"
print("La union de ambos dataframes contiene ", len(merged_df.columns), " columnas")

"""Usemos la nueva columna ```Full``` para actualizar la columna ```Position``` para que contenga el significado y abreviatura de la posición:

```merged_df["Full"] + " (" + merged_df["Position"] +")"```
"""

# Concatenacion de strings (Columnas Full y Position). Inserta valor Full, agrega espacio y parentesis, luego valor Position y cierra parentesis.
merged_df["Position"] = merged_df["Full"] + " (" + merged_df["Position"] +")"# <completado>
merged_df.head()

"""Muestra la columna actualizada:"""

merged_df["Position"].head(3)

"""Ahora, tenemos algunas columnas adicionales que ya no son útiles.

Eliminemos las columnas ```Abbreviation``` y ```Full``` del dataframe usando ```drop()```:
"""

merged_df = merged_df.drop(["Abbreviation", "Full"], axis=1) # Axis=1 indica a Pandas eliminar columnas (no filas).

merged_df.head(3)

assert len(merged_df.columns) == 21, "Error"

"""Asignemos al dataframe original ```fifa_df``` el nuevo dataframe con el tratamiento de datos ya realizado:"""

fifa_df = merged_df
fifa_df.head()

"""## Análisis exploratorio

En esta sección, utilizarás distintos métodos de los dataframes de pandas para generar un análisis exploratorio. En un análisis exploratorio, se busca explorar, resumir y entender los datos.

### Jugadores con el mayor valor comercial y jugadores mejores pagados

Muestra el **Top 3** de jugadores con mayor valor (```Value```) en el mercado.
"""

# Se debe definir una variable para asignar el dataframe fifa_df, de otra manera no me resulto.
top_salario = fifa_df.nlargest(3, "Value") # <completado>
top_salario

top_valor = fifa_df.sort_values(by="Value", ascending=False).head(3)
top_valor

"""Muestra el **Top 3** de jugadores mejores pagados en el mundo (Salarios más altos, ```Wage```)."""

mejor_pago = fifa_df.nlargest(3, "Wage")
mejor_pago

mejor_pagado = fifa_df.sort_values(by="Wage", ascending=False).head(3)
mejor_pagado  # <completado>

"""### Potencial por alcanzar

Utiliza operaciones Crea una nueva columna que  muestre el potencial por alcanzar ```Potential left``` de cada jugador en el conjunto de datos. El potencial por alcanzar puede ser calculado mediante ```Potential - Overall```.
"""

fifa_df["Potential left"] = fifa_df["Potential"] - fifa_df["Overall"]# <rellena>
fifa_df.head()

# Selecciona los valores mas altos, pero en caso de repetidos, puede eligir aleatoriamente.
# nlargest() esta optimizado para rendimienot y no prioriza el orden de desempate a menos que se especifique.
# Usa nlargest() si solo necesitas los valores mas altos y no te importa el orden de empates.

# mayor_potencial = fifa_df.nlargest(3, "Potential left", keep="first")
# mayor_potencial

# Ordena todos los registros de la columna. Si hay empates, mantiene el orden original del DataFrame o usa indices.
# Usa sort_values().head() si necesitas controlar el orden de desempate (ej. por nombre, indice, ect.).

mayor_potential = fifa_df.sort_values(by="Potential left", ascending=False).head(3)
mayor_potential

"""### Jóvenes promesa

Utiliza las funciones de Pandas para encontrar el **top 5** de jugadores "promesa" menores de 22 años. Ordena ascendentemente el dataframe según el potencial (```Potential```), potencial por alcanzar (```Potential left```) y su nivel (```Overall ```) actual.
"""

judagores_promesa = fifa_df[fifa_df["Age"] < 22] #<completado>
top_promesa = judagores_promesa.sort_values(by=["Potential", "Potential left", "Overall"], ascending=[True, True, True])#.head(5)
top5_promesa = top_promesa.head(5)
print("Top 5 de hugadores promesa menores de 22 años:")
print(top5_promesa[["Name", "Age", "Potential", "Potential left", "Overall"]])

"""### Mejor defensa en el mundo

Encuentra al jugador con el mayor puntaje en la columna ```Defense```:

*Tip: utiliza el método ```idxmax``` para encontrar la fila donde se encuentra el mejor defensa. Después usa el índice para acceder a los datos de la fila.*
"""

indice_mejor_defensa = fifa_df["Defense"].idxmax()
mejor_defensa = fifa_df.loc[indice_mejor_defensa]
print(mejor_defensa[["Name", "Club", "Defense", "Position"]]) # <completa>

mejor_defensa[["Name", "Club", "Defense", "Position"]].to_frame().T

"""### Porcentaje pie preferido

Calcula el porcentaje mundial de jugadores que prefieren utilizar su pierna derecha para controlar el balón y el porcentaje que prefiere utilizar la pierna izquierda.

*Tip: El método ```value_counts()``` de objetos Series podría resultarte particularmente útil para esta tarea.*
"""

# imprime la columna "Preferred Foot" usando el metodo unique() para saber que valores hay y como estan escritos (Right y Left)
print("Distintos valores en la columna:", fifa_df["Preferred Foot"].unique())

# Para saber cuantos valores diferentes tiene la columna, una .nunique()
print("Cauntos valores diferentes hay?", fifa_df["Preferred Foot"].nunique())

print("Conteo de jugadores que usa el pie Derecho o Izquierdo de los datos de la columna 'Preferred Foot'")
conteo_pie_pref = fifa_df["Preferred Foot"].value_counts()
print(conteo_pie_pref.to_frame().T)

fifa_df.shape[0]  # cantidad de datos en la columna (17,918)

porcentaje_derecha = (conteo_pie_pref["Right"] / fifa_df.shape[0]) * 100
porcentaje_izquierda = (conteo_pie_pref["Left"] / fifa_df.shape[0]) * 100

print("Porcentaje de jugadores que prefieren usar la pierna derecha: {:.2f}%".format(porcentaje_derecha))
print("Porcentaje de jugadores que prefieren usar la pierna izquierda: {:.2f}%".format(porcentaje_izquierda))

"""### Equipos con mayor talento promedio

Utiliza funciones de agregación y de agrupamiento para obtener a los equipos con el mejor promedio de nivel (```Overall```) entre sus jugadores.
"""

fifa_df[["Club"]].groupby(fifa_df.Club).count()

# <completa>
promedio_por_equipo =fifa_df.groupby("Club")["Overall"].mean()

mejores_equipos = promedio_por_equipo.sort_values(ascending=False).round(4)

# .round(4) muestra cuatro digitos despues del punto. La funcion de Pandas "pd.set_option()" configura opciones de visualizacion globales
# para todos los DataFrames y Series en tu sesion de Python.

# pd.set_option('display.float_format', '{:.2f}'.format)
# print(mejores_equipos.head())

# Con este metodo muestra nuevamente la notacion cientifica.
# pd.reset_option('display.float_format')

print("Equipos con el mejor promedio de nivel (Overall):")
print(mejores_equipos.head())

"""### Equipos con más costosos (valor comercial)

Utiliza funciones de agregación y agrupamiento para encontrar el valor total de de cada club, esto es, la suma de los valores individuales de los jugadores de los Club.

Ordena de manera descendente para mostrar los clubs más costosos del mundo.
"""

# <completa>

valor_comercial_equipo = fifa_df.groupby("Club")["Value"].sum()
equipos_mas_costosos = valor_comercial_equipo.sort_values(ascending=False)
equipos_mas_costosos.head(5)

"""### ¿Qué equipos tienen más mexicanos?

Muestra un top 5 de equipos con más jugadores mexicanos en el mundo.

Primero, crea un dataframe que contiene unicamente jugadores mexicanos:

*Tip: Filtra el dataframe usando ```Nationality==Mexico```*.
"""

# <completa>  Indexacion booleana:
# Del DataFrame completo (fifa_df) del que filtraras los datos, crearas una "mascara booleana" (una serie de True-Flase, True=Mexico), usando:
# (fifa_df["Nationality"] == "Mexico") --> es la mascara booleana
jugadores_mexicanos = fifa_df[(fifa_df["Nationality"] == "Mexico")]

# De los datos filtrados "jugadores_mexicanos", se accede a la columna "Club" para contar los jugadores mexicanos que hay en cada equipo con .value_counts().
jugadores_por_equipo = jugadores_mexicanos["Club"].value_counts()

top_equipos_mexicanos = jugadores_por_equipo.head(5)

print(top_equipos_mexicanos)

"""Agrupa por el nombre del club y cuenta:"""

# En orden "alfabetico" de clubs, muestra la cantidad de jugadores mexicanos por equipo
# Primero clasifica los mexicanos por nacionalidad
juagadores_mexicanos = fifa_df[fifa_df["Nationality"] == "Mexico"]

# Despues de filtrar los datos con mexicanos, se clasifican los equipos por la cantidad de jugadores mexicanos
jugadores_por_club = jugadores_mexicanos.groupby("Club").size()
# jugadores_por_club.describe()

print(jugadores_por_club)

"""## Visualización

Utiliza las opciones de visualización de Pandas.

### Histograma de las edades de los jugadores de futbol

Selecciona la columna ``Age``` del dataframe ```fifa_df``` y muestra el histograma usando las opciones de visualización de Pandas:
"""

# <rellena>.plot.hist(bins=10)
# Importar la libreria matplotlib.pyplot

import matplotlib.pyplot as plt

fifa_df["Age"].plot.hist(bins=50)
plt.title("Histograma de las edades de los jugadores de futbol")
plt.xlabel("Edad")
plt.ylabel("Frecuencia")
plt.show()

# Seleccion por rangos de edades
bins_personalizados = pd.cut(fifa_df["Age"], bins=[16, 20, 25, 30, 40, 50])
bins_personalizados.value_counts().plot.bar()
plt.title("Histograma de las edades de los jugadores de futbol")
plt.xlabel("Edad")
plt.ylabel("Frecuencia")
plt.show()

"""### Gráfica de Pie (Preferred Foot)

Selecciónes el conteo de valores del pie preferido (columna ```Preferred Foot```) y muestra la información mediante una gráfica de Pie:
"""

# <completa>
# Primero crea un DataFrame con el conteo de pie preferido de los jugadores (dercho-izquierdo)
# autopct (auto percentage) muestra el porcentaje de cada porcion. Agrega etiquetas numericas dentro de cada porcion del grafico pie.
# %1.1f%%, 1 entero + 1 decimal + %

conteo_pie_pref = fifa_df["Preferred Foot"].value_counts().plot.pie(autopct='%1.1f%%', colors=["lightblue", "lightgreen"], startangle=40, shadow=True)

plt.title("Preferencia de Pie de los Jugadores")
plt.axis("equal")  # Asegura que la grafica pie sea un circulo. "scaled" ajusta la caja del grafico para encajar los datos.
                   # "auto" por defecto sin igualar escalas, "tight" ajusta limites de ejes para encajar todos los datos.
plt.show()

"""### Gráfica de dispersión Edad vs Potential left

Ahora, utiliza una gráfica de dispersión para visualizar el comportamiento del potencial por alcanzar (```Potential left```) de acuerdo a las edades de los jugadores:

*Tip: La gráfica debe mostrar la edad en un eje y el potencial por alcanzar en el otro.*
"""

# <completa>
# con "s" puedes reducir el tamaño de los puntos de la grafica, por default es 20 si no incluyes "s=<tamaño>"
# "alpha=0.5" para transparencia en puntos superpuestos.
dispersion_Edad_vs_Potencial = fifa_df.plot.scatter("Age", "Potential left", figsize=(6, 3), s=10, alpha =0.3, color="blue")
plt.title("Age vs Potential left")
plt.xlabel("Age")
plt.ylabel("Potential left")
plt.show()

"""¿Qué otras variables o mezcla de variables sería interesante visualizar?

# Desafío Adicional

En la práctica con Numpy, creaste un modelo para identificar imágenes de dígitos escritos a mano.

Para este nuevo conjunto de datos, ¿podrías usar una metodología similar para encontrar la posición en el campo de un jugador solamente usando los valores de su habilidades?

Skills: ```Shooting 	Defense 	Passing 	Physical 	Control 	Mental 	GoalKeeping```
"""

# sklearn -> libreria para Machine Learning, prepara datos y evalua modelos.
# train_test_split : divide un conjunto de datos en subconjuntos aleatorios, ideal para divisiones rapidas y prototipado.
# - Datos de entrenamiento [X_train, Y_train), entrena modelo. Datos de prueba [X_test, Y_test], evalua rendimiento.
# X: caracteristicas (variables independientes), Y: Etiquetas (variable objetivo)
# cross_val_score: esencial para evaluar modelos de manera robusta antes de llevarlos a produccion y para encontrar el k optimo.
# neighbors -> algoritmo de clasificacion supervisada basado en la proximidadd de los datos
 # (kNN-> clasifica nuevos puntos basados en la mayoria de votos de sus k vecinos mas cercanos, eje: k= 3, si dos son "Perro" y 1 "Gato", la prediccion sera "Perro")

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler #para estandarizar (normalizar) los datos (con media de 0 y desviacion estandar de 1) lo que mejora el rendimiento.
import numpy as np

# Seleccionar características relevantes
features = ["Shooting", "Defense", "Passing", "Physical", "Control", "Mental", "GoalKeeping"]
df_aux = pd.read_csv("https://raw.githubusercontent.com/DCDPUAEM/DCDP/main/01%20Programaci%C3%B3n%20en%20Python/data/fifa/players.csv", sep=',', header=0)
# Selecciona las columnas de habilidades, concatena (agrega) la columna "Position" y Eliminar filas con valores nulos en X o y con .dropna()
fifa_cleaned = df_aux[features + ["Position"]].dropna()

# Seleccionar características y etiquetas después de limpiar los datos
X = fifa_cleaned[features]
y = fifa_cleaned["Position"]

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Verifica las divisiones
print(f"80 % Entrenamiento: {X_train.shape[0]} muestras")
print(f"20 % Prueba: {X_test.shape[0]} muestras")
print(f"De un total de:", len(fifa_cleaned["Position"]), "muestras")

# Normalizar las características
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Entrenar el clasificador k-NN. n_neighbors define el numero de vecinos mas cercanos para tomar decision.
# K=5, significa que mirará los 5 puntos mas cercanos para predecir la clase de una nueva muestra.
# k-NN algoritmo "lazy", no aprende un modelo, ua datos para la prediccion.
knn_classifier = KNeighborsClassifier(n_neighbors=5)
knn_classifier.fit(X_train_scaled, y_train)

# Evaluar el modelo utilizando validación cruzada
cv_scores = cross_val_score(knn_classifier, X_train_scaled, y_train, cv=5)
accuracy_knn = cv_scores.mean()

# Predicción de nuevas instancias
new_player_skills = np.array([[70, 65, 75, 80, 85, 70, 60]])  # Habilidades del nuevo jugador
new_player_df = pd.DataFrame(new_player_skills, columns=features)

# Escalar las características del nuevo jugador
new_player_skills_scaled = scaler.transform(new_player_df)
print(new_player_skills_scaled)

# Predecir la posición del nuevo jugador
predicted_position_knn = knn_classifier.predict(new_player_skills_scaled)[0]

# Imprimir resultados
print(f"Accuracy de k-NN con validación cruzada: {accuracy_knn:.4f}")
print(f"La posición predicha del nuevo jugador es: {predicted_position_knn}")

# Función para calcular la distancia euclidiana
# p1 y p2 son arrays de Numpy (o listas)
def euclidean_distance(p1, p2):
    return np.sqrt(np.sum((p1 - p2) ** 2))

# Seleccionar características y etiquetas
X = fifa_cleaned[features]
y = fifa_cleaned["Position"]

# División manual 80% entrenamiento, 20% prueba
num_players = len(X)
split_idx = int(0.8 * num_players)
X_train_manual, X_test_manual = X.iloc[:split_idx], X.iloc[split_idx:]
y_train_manual, y_test_manual = y.iloc[:split_idx], y.iloc[split_idx:]

print(f" numero de filas en el arreglo X son: {num_players}")

# Obtener posiciones únicas y sus representantes promedio
unique_positions = y_train_manual.unique()
representatives = {pos: X_train_manual.loc[y_train_manual == pos].mean().values for pos in unique_positions}

# Nuevo jugador a clasificar (ejemplo)
new_player = np.array([70, 65, 75, 80, 85, 70, 60])

# Calcular la distancia euclidiana con cada representante de posición
distances = {position: euclidean_distance(new_player, reps) for position, reps in representatives.items()}

# Obtener la posición con la menor distancia euclidiana
predicted_position_euclidean = min(distances, key=distances.get)

# Evaluación de la precisión del método de distancia euclidiana
correct_predictions = sum(
    min({pos: euclidean_distance(X_test_manual.iloc[i].values, reps) for pos, reps in representatives.items()},
        key=lambda x: x[1]) == y_test_manual.iloc[i]
    for i in range(len(X_test_manual))
)
accuracy_euclidean = correct_predictions / len(X_test_manual)

# Imprimir resultados
print(f"Accuracy del método de Distancia Euclidiana: {accuracy_euclidean:.4f}")
print(f"La posición predicha del nuevo jugador es: {predicted_position_euclidean}")

"""# **Clasificación de Posiciones en Fútbol usando k-NN y Distancia Euclidiana Manual**

## **Introducción**
El objetivo de este ejercicio es clasificar a jugadores de fútbol en diferentes posiciones basándonos en sus atributos técnicos y físicos. Implementamos dos métodos distintos:

1. **k-Nearest Neighbors (k-NN) con `sklearn`**: Un enfoque basado en aprendizaje supervisado que clasifica jugadores en función de los k vecinos más cercanos.
2. **Distancia Euclidiana Manual**: Un enfoque más rudimentario que asigna la posición según la distancia a valores promedio predefinidos para cada posición.

Cada método tiene ventajas y desventajas, aquí te explico sus diferencias, los resultados obtenidos y discutiremos posibles mejoras.

---

## **¿Por qué usar k-NN en este ejercicio?**
El algoritmo **k-Nearest Neighbors (k-NN)** es un clasificador basado en la similitud entre ejemplos previos. Funciona bien en problemas donde las clases tienen cierta continuidad en el espacio de características. En el fútbol, las posiciones de los jugadores pueden agruparse según atributos como "Shooting", "Defense", "Passing", etc.

**Razones para usar k-NN:**
- **Es no paramétrico**: No asume una relación específica entre las variables.
- **Es intuitivo**: Clasifica con base en ejemplos previos, imitando la toma de decisiones humana.
- **Se adapta bien a problemas multiclase**: En el fútbol hay múltiples posiciones y k-NN permite encontrar similitudes basadas en características cuantificables.
- **Es robusto ante datos no lineales**: No asume que las clases sean separables linealmente.

### **¿Por qué `k=5` en k-NN?**
El parámetro **`n_neighbors`** define cuántos vecinos cercanos consideramos para clasificar un nuevo jugador. Elegimos `k=5` porque:

- **Evita sensibilidad al ruido**: Si \( k=1 \), el modelo puede sobreajustarse a valores atípicos.
- **Promueve estabilidad en la predicción**: Si \( k \) es demasiado grande, la clasificación puede volverse demasiado general.
- **Regla general**: Un valor de \( k \) entre **3 y 7** es comúnmente utilizado en problemas de clasificación.

Para encontrar el valor óptimo de \( k \), podríamos hacer **validación cruzada** y probar diferentes valores, buscando el que maximice la precisión.

---

## **¿Por qué normalizar los datos antes de aplicar k-NN?**
El modelo k-NN se basa en la distancia entre puntos en el espacio de características. Algunas características como "Physical" pueden tener valores más altos en comparación con "Shooting" o "Mental". Si no escalamos los datos, los atributos con valores más grandes dominarán el cálculo de la distancia.

Por eso usamos **`StandardScaler()`** de `sklearn`, que transforma cada característica para que tenga:
- **Media = 0**
- **Desviación estándar = 1**

Esto garantiza que cada característica contribuya equitativamente a la clasificación.

---

## **Distancia Euclidiana Manual**
La **distancia euclidiana** entre dos puntos \( p \) y \( q \) en un espacio de \( n \) dimensiones se define como:

$$
d(p, q) = \sqrt{\sum_{i=1}^{n} (p_i - q_i)^2}
$$

### **¿Cómo funciona este método en este ejercicio?**
1. Calculamos el **promedio** de los atributos para cada posición en el conjunto de entrenamiento.
2. Para un nuevo jugador, calculamos la distancia euclidiana con respecto a cada posición promedio.
3. La posición con la menor distancia se asigna al jugador.

Este método es una versión simplificada de **k-NN con k=1**, donde solo tomamos un representante de cada clase.

---

## **Comparación entre ambos métodos**
| Método                | Ventajas | Desventajas |
|----------------------|-----------|-------------|
| **k-NN con `sklearn`**  | Mayor precisión. Considera múltiples vecinos. Permite validación cruzada. | Computacionalmente más costoso en grandes datasets. |
| **Distancia Euclidiana Manual** | Simplicidad y rapidez. No requiere librerías especializadas. | No es flexible, depende de valores fijos representativos de cada posición. |

---

## **Análisis de los Resultados**
Veamos los resultados obtenidos en cada método:

### **1. k-NN con `sklearn`**
- **Precisión del modelo con validación cruzada**: 41.67%
- **Predicción para un nuevo jugador**: `CM` (Centrocampista)

#### **¿Por qué esta precisión?**
- El modelo usa **múltiples vecinos** para hacer predicciones, lo que suaviza el impacto del ruido en los datos.
- Sin embargo, una precisión del **41.67%** sugiere que las posiciones no están claramente separadas en el espacio de características. Esto podría deberse a que algunos atributos no son suficientes para definir una posición única.

#### **¿Cómo mejorar la precisión?**
- **Probar diferentes valores de `k`** con validación cruzada.
- **Agregar más características** que puedan mejorar la separación entre posiciones.
- **Probar modelos más avanzados** como SVM, Random Forest o redes neuronales.

---

### **2. Distancia Euclidiana Manual**
- **Precisión del método manual**: **4.66%**
- **Predicción para un nuevo jugador**: `LF` (Lateral Izquierdo)

#### **¿Por qué la precisión es tan baja?**
- Este método **no utiliza múltiples vecinos**, sino un único valor promedio por posición, lo cual es una **gran limitación**.
- **No considera la variabilidad dentro de cada posición**. Algunos jugadores en la misma posición pueden tener atributos muy diferentes.
- **No usa normalización**, lo que sesga la distancia en favor de las características con valores más altos.
- La distribución de los datos puede ser **no lineal**, lo que significa que calcular solo una distancia euclidiana no es suficiente para capturar patrones más complejos.

#### **¿Cómo mejorar este método?**
- **Agrupar jugadores con clustering** (k-Means, DBSCAN *(**Density-Based Spatial Clustering of Applications with Noise**)*) para encontrar grupos naturales en lugar de promedios fijos.
- **Usar pesos en la distancia euclidiana** para dar más importancia a ciertas características.
- **Incorporar normalización** antes de calcular las distancias.

---

## **Conclusión**
| Método | Precisión | Recomendado para |
|--------|-----------|------------------|
| **k-NN con `sklearn`** | 41.67% | Clasificación en conjuntos de datos más grandes con muchas instancias. |
| **Distancia Euclidiana Manual** | 4.66% | Una aproximación rápida y educativa, pero no práctica para clasificación real. |

En resumen:
- **k-NN es superior** porque considera múltiples vecinos y usa validación cruzada.
- **La distancia euclidiana manual es demasiado simple** y no captura la variabilidad dentro de cada posición.
- **La normalización es clave** para evitar que ciertas características dominen el cálculo de distancias.
- Para mejorar la clasificación, podríamos **probar otros modelos supervisados** como SVM o Random Forest.

Este ejercicio demuestra la importancia de elegir la técnica adecuada para cada problema, y cómo pequeños ajustes como la normalización pueden hacer una gran diferencia en los resultados.


"""
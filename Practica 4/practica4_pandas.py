# -*- coding: utf-8 -*-
"""Practica4_Pandas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/DCDPUAEM/DCDP/blob/main/01%20Programaci%C3%B3n%20en%20Python/notebooks/exercises/Practica4_Pandas.ipynb

<a href="https://colab.research.google.com/github/DCDPUAEM/DCDP/blob/main/01%20Programaci%C3%B3n%20en%20Python/notebooks/exercises/Practica4_Pandas.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""### __Data set de vinos del mundo__

Esta es una versi√≥n reducida de la base de datos [winemag-data](https://gist.github.com/clairehq/79acab35be50eaf1c383948ed3fd1129), que contiene una rese√±a en ingl√©s sobre una gran cantidad de vinos del mundo.

### __Descripci√≥n de los campos__

 - **country**: El pa√≠s de donde proviene el vino
 - **description** : Algunas frases de un sommelier que describen el sabor, olor, apariencia, sensaci√≥n, etc. del vino.
 - **designation**: La denominaci√≥n. El vi√±edo dentro de la bodega de donde proceden las uvas que elaboraron el vino.
 - **points**: la cantidad de puntos que WineEnthusiast calific√≥ al vino en una escala del 1 al 100 (aunque dicen que solo publican rese√±as de vinos con una puntuaci√≥n> = 80).
 - **price**: El costo de una botella de vino.
 - **province**: La provincia o estado de donde proviene el vino
 - **region_1**: el √°rea de cultivo de vino en una provincia o estado (es decir, Napa)
 - **region_2**: a veces hay regiones m√°s espec√≠ficas, especificadas dentro de un √°rea de cultivo del vino (es decir, Rutherford dentro del Valle de Napa), pero este valor a veces puede estar en blanco.
 - **taster_name**: nombre de la persona que prob√≥ y revis√≥ el vino.
 - **taster_twitter_handle**: identificador de Twitter para la persona que prob√≥ y revis√≥ el vino.
 - **title**: el t√≠tulo de la rese√±a de vinos, que a menudo contiene la cosecha si est√° interesado en extraer esa caracter√≠stica.
 - **variety**: la variedad: el tipo de uva utilizada para elaborar el vino (es decir, Pinot Noir).
 - **winery**: la bodega que hizo el vino.

### TEST
"""

# Fetch the dataset using the raw GitHub URL.
!curl --remote-name \
     -H 'Accept: application/vnd.github.v3.raw' \
     --location https://raw.githubusercontent.com/DCDPUAEM/DCDP/main/01%20Programaci%C3%B3n%20en%20Python/data/winemag-data-less.csv

# leemos el dataframe usando read_csv
df = pd.read_csv("winemag-data-less.csv")
print(df.info())
df.head(3)

#Tiremos la columna Unnamed
df.drop('Unnamed: 0',axis=1,inplace=True)
df.head(3)

"""### __Veamos cuantas rese√±as de vinos mexicanos tenemos.__

#### &#9758; Construye una nueva Tabla con las rese√±as de vinos mexicanos.
- Qu√©date **s√≥lo** con las siguientes columnas: `['country','winery','variety','description','points','price']`
- Haz que el √≠ndice se reinicie en 0.
- Guarda este DataFrame en la variable vinosMX.
"""

"""
SECUENCIA:
1. Ubicar todos los registros de M√©xico usando indexaci√≥n booleana
2. De este DataFrame resultante, extraer solamente las columnas solicitadas.
3. Reiniciar el √≠ndice usando reset_index()
4. Tirar (drop) la nueva columna index
5. Asignar el resultado de este proceso a la variable vinosMX
"""
# TU CODIGO
# 1. Ubicar todos los registros de M√©xico usando indexaci√≥n booleana
vinosMX = df[df['country']=='Mexico']

# 2. De este DataFrame resultante, extraer solamente las columnas solicitadas.
vinosMX = vinosMX[['country','winery','variety','description','points','price']]
#print(vinosMX.head(3))

# 3. Reiniciar el √≠ndice usando reset_index()
vinosMX = vinosMX.reset_index()

# 4. Tirar (drop) la nueva columna index
vinosMX = vinosMX.drop('index',axis=1)
vinosMX

"""### __Veamos cuantas rese√±as de vinos por pa√≠s tenemos.__

#### &#9758; Muestra en una gr√°fica de barras la distribuci√≥n del n√∫mero de rese√±as por pa√≠s (_top 10_).

#### Puedes auxiliarte con alguna de estos m√©todos de Pandas:
 - [pandas.DataFrame.count](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.count.html)
 - [pandas.Series.value_counts](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.value_counts.html)
 - [pandas.Series.index](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.index.html)
 - [pandas.Series.values](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.values.html)
"""

"""
SECUENCIA:
1. Ubicar el nombre de la columna de pa√≠s
2. Sobre esta columna, obtener la Serie correspondiente
3. Hacer un conteo de los valores √∫nicos sobre esta Serie

4. X en la gr√°fica de barras son los pa√≠ses (√≠ndice de la Serie)
5. Y en la gr√°fica de barras son los conteos por pa√≠s (values de la Serie)
6. Usar Seaborn para graficar el diagrama de barras
7. Rotular la gr√°fica y los ejes
"""
# 1. Ubicar el nombre de la columna de pa√≠s
# 2. Sobre esta columna, obtener la Serie correspondiente
# 3. Hacer un conteo de los valores √∫nicos sobre esta Serie
conteos=df.country.value_counts()

# 4. X en la gr√°fica de barras son los pa√≠ses (√≠ndice de la Serie)
# 5. Y en la gr√°fica de barras son los conteos por pa√≠s (values de la Serie)
x = conteos.index
y = conteos.values

plt.figure(figsize=(16,7))
colors = ['blue', 'orange', 'green', 'red', 'purple', 'brown', 'pink', 'gray', 'cyan', 'magenta']
#sns.barplot(x=x[:10], y=y[:10], palette= "hls") # "viridis" gradiente verde-azul. Se debe asignar el slice "X[ :10]" al parametro "x", por ello x=x[..]

# En una sola l√≠nea:
# Se debe agregar HUE --> "hue=df.country.value_counts().index[:10] en nuevas versiones de seaborn, acompa√±ado de "palette= "hls" y "legend=True o False"
sns.barplot(x=df.country.value_counts().index[:10], y=df.country.value_counts().values[:10], hue=df.country.value_counts().index[:10], palette= "hls", legend=True)

plt.xlabel("Pa√≠ses")
plt.ylabel("N√∫mero de vinos")
plt.title("Rese√±as por pa√≠s (Top 10)")

plt.show()

"""### __Veamos ahora cu√°l es el precio promedio por cada pa√≠s.__

#### &#9758; Muestra en una gr√°fica de barras el precio promedio por pa√≠s, en orden descendente (_top 10_).

Puedes consultar:
 - [pandas.DataFrame.groupby](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html)

#### &#9758; ¬øCu√°l ser√≠a el precio promedio por variedad?

üôÇ __Escribe la secuencia de pasos que tendr√≠as que realizar.__
"""

df.head(3) # Existen valores NaN en columna "Price"? S√≠, en la primer fila, cuantos hay en total en esta columna?

df.isna().sum(axis=0).to_frame().T # Se cuentan los valores NaN que hay en toda la columna "Price" (4245) y saber que otrso NaN hay en otras columnas

df.columns

# Para saber si hay valores NaN:  hay_nans = df["price"].isna().any()
# print(hay_nans) --> True:Si hay

num_nans = df["price"].isna().sum()
print(num_nans)

limpiar_nans = df.dropna(subset=['price'])
limpiar_nans.isna().sum(axis=0).to_frame().T

hay_nans2 = limpiar_nans["price"].isna().any()
print(hay_nans2)
limpiar_nans.head(3)

df = limpiar_nans

promedios = df.groupby('country')['price'].mean().sort_values(ascending=False)

# 2. Crear el gr√°fico
plt.figure(figsize=(12, 6))
sns.barplot(
    x=promedios.index[:10],  # Pa√≠ses en eje X
    y=promedios.values[:10], # Promedios en eje Y
    hue=promedios.index[:10], # Colores en Paises
    palette="hls",   # Paleta de colores
    legend=True
)

plt.title('Precio promedio por pa√≠s - Top 10', fontsize=14)
plt.xlabel('Pa√≠s', fontsize=12) # Tama√±o fuente en Etiqueta Pa√≠s
plt.ylabel('Precio promedio (USD)', fontsize=12) # Tama√±o fuente en Etiqueta Promedio
plt.xticks(rotation=-45, fontsize=8)  # Rotar nombres de pa√≠ses para legibilidad y tama√±o fuente en paises
plt.yticks(fontsize=8)  # Tama√±o fuente en valores promedio
plt.tight_layout()       # Ajustar m√°rgenes
plt.show()

"""#### Agregando anotaciones a nuestros gr√°ficos

Es posible agregar informaci√≥n a nuestros gr√°ficos, en forma de texto, o dibujos (e.g. flechas, l√≠neas, c√≠rculos, etc.). Para ello, se utiliza la anotaci√≥n (annotate) de ejes (axes). Detallar aqu√≠ c√≥mo funciona nos llevar√≠a mucho tiempo. Puedes consultar la documentaci√≥n en estas ligas:

- [matplotlib.Artist](https://matplotlib.org/3.3.3/api/artist_api.html#matplotlib.artist.Artist)
    - [Artist tutorial](https://matplotlib.org/3.3.3/tutorials/intermediate/artists.html)
- [matplotlib.axes](https://matplotlib.org/3.3.3/api/axes_api.html#matplotlib.axes.Axes)
- [matplotlib.patches.Patch](https://matplotlib.org/3.3.3/api/axes_api.html#matplotlib.axes.Axes)
- [matplotlib.patches.Rectangle](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.patches.Rectangle.html)
- [matplotlib.pyplot.annotate](https://matplotlib.org/3.3.3/api/_as_gen/matplotlib.pyplot.annotate.html)
"""

#Definimos el tama√±o del canvas
plt.figure(figsize=(12,5))

# la variable "ax" (axes) contiene la informaci√≥n  del gr√°fico de barras.
# En particular, contiene todo lo relativo a los parches (rect√°ngulos) del barplot.
ax = sns.barplot(x=x[:10], y=y[:10], hue=promedios.index[:10], palette="hls")


# Recorremos cada rect√°ngulo
for p in ax.patches:
    ax.annotate("%.2f" % p.get_height(),\
                (p.get_x() + p.get_width() / 2., p.get_height()),\
                ha='center', va='center', fontsize=8, color='gray',\
                xytext=(0, 6),\
                textcoords='offset points')

plt.show()

"""### __Ahora queremos darnos una idea de cu√°les podr√≠an ser los pa√≠ses cuyos vinos tienen una mejor raz√≥n calidad-precio en promedio.__

#### &#9758; Muestra en una gr√°fica de barras la raz√≥n puntos/precio promedio por pa√≠s, en orden descendente (_top 10_). Muestra los valores de la raz√≥n sobre cada barra.

‚úã __Recuerda que si divides entre 0 o Nan obtendr√°s inf o nan__

üôÇ __Escribe la secuencia de pasos que tendr√≠as que realizar.__
"""

plt.figure(figsize=(8,4))
sns.boxplot(x=df.points)
plt.title("Boxplot del puntaje (calidad)")
plt.show()

# Para saber si hay valores NaN:  hay_nans = df["price"].isna().any()
# print(hay_nans) --> True:Si hay

nan_pais = df["country"].isna().sum()
print(nan_pais)

cero_nan_country = df.dropna(subset=['country'])
cero_nan_country.isna().sum(axis=0).to_frame().T

hay_aun_nan_country = cero_nan_country["price"].isna().any()
print(hay_aun_nan_country)
cero_nan_country.head(3)

df_2 = df[df['points'] <= float(97.5)]
df_2.points.value_counts().to_frame().T

df = df_2

df["razon_puntos_por_precio"] = df["points"] / df["price"]
mejor_relacion_por_pais = df.groupby("country")["razon_puntos_por_precio"].mean().sort_values(ascending=False).head(10)

plt.figure(figsize=(10,5))

x = mejor_relacion_por_pais.index
y = mejor_relacion_por_pais.values

ax = sns.barplot(x=x[:10], y=y[:10], hue=mejor_relacion_por_pais.index[:10], palette="viridis", legend=True)
plt.title("Mejor raz√≥n calidad/precio por pa√≠s (Top 10)")
plt.xlabel("Pa√≠s")
plt.xticks(rotation= 45, ha="right", fontsize = 8)
plt.ylabel("Raz√≥n Puntos/Precio")

plt.legend(
    title="Pa√≠s",  # T√≠tulo opcional
    loc='upper right',  # Posici√≥n (aj√∫stala seg√∫n necesites)
    bbox_to_anchor=(1, 1.0), borderaxespad=0.5, fontsize=5 )  # Para ajustes finos (opcional)

for p in ax.patches:
    ax.annotate("%.2f" % p.get_height(), (p.get_x() + p.get_width() / 2., p.get_height()),
                 ha='center', va='center', fontsize=8, color='gray', xytext=(0, 5),
                 textcoords='offset points')
plt.show()

"""### __¬øQu√© vinos tienen la mejor puntuaci√≥n y a qu√© pa√≠ses pertenecen?__

#### &#9758; Muestra en una gr√°fica de pastel la proporci√≥n de los pa√≠ses que tienen los 20 mejores vinos; es decir, los primeros 20 de mayor puntaje.  
"""

import matplotlib.pyplot as plt
import numpy as np

top_20_points = df.groupby('country')['points'].mean().sort_values(ascending=False).head(20)

# Datos
labels = top_20_points.index
sizes = top_20_points.values
colors = plt.cm.rainbow(np.linspace(0, 1, len(labels)))

# Crear gr√°fico con plt.pie() (devuelve wedges, texts, autotexts)
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    colors=colors,
    startangle= 90,
    pctdistance=0.9,
    textprops={'fontsize': 7},
    wedgeprops={'edgecolor': 'white', 'linewidth': 0.5}
)

# Personalizar autotexts (ahora la variable existe)
plt.setp(autotexts, size=6, weight='bold', color='white')

# A√±adir t√≠tulo
plt.title('Top 20 pa√≠ses por puntuaci√≥n promedio', fontsize=14, pad=20, weight='bold')

# Mostrar gr√°fico
plt.tight_layout()
plt.axis('equal')
plt.show()

"""### __¬øCu√°les son las 10 variedades de uva m√°s abundantes y en qu√© proporci√≥n?__

#### &#9758; Da una soluci√≥n utilizando s√≥lo dos l√≠neas de c√≥digo
"""

df.head(2)

#TU CODIGO
top_10_variedades = df['variety'].value_counts().head(10)
print(top_10_variedades / top_10_variedades.sum() * 100)  # Proporci√≥n porcentual

# Datos
labels = top_10_variedades.index
sizes = top_10_variedades.values
colors = plt.cm.viridis(np.linspace(0, 1, len(labels)))

# Crear gr√°fico con plt.pie() (devuelve wedges, texts, autotexts)
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    colors=colors,
    startangle= 90,
    pctdistance=0.8,
    textprops={'fontsize': 10},
    wedgeprops={'edgecolor': 'white', 'linewidth': 0.5}
)

# Personalizar autotexts (ahora la variable existe)
plt.setp(autotexts, size=8, weight='bold', color='white')

# A√±adir t√≠tulo
plt.title('Las 10 variedades de uva m√°s abundantes y su proporci√≥n', fontsize=14, pad=20, weight='bold')

# Mostrar gr√°fico
plt.tight_layout()
plt.axis('equal')
plt.show()

"""### __¬øCu√°les son las 20 bodegas m√°s mencionadas y en qu√© proporci√≥n?__

#### &#9758; Da una soluci√≥n utilizando s√≥lo dos l√≠neas de c√≥digo
"""

# La suma total de las mejores 20 bodegas es: 1375, la proporcion de cada bodega estara en funcion de esta suma.
top_20_bodegas_1 = df['winery'].value_counts().head(20)
print(top_20_bodegas_1.sum())

#TU CODIGO
top_20_bodegas_1 = df['winery'].value_counts().head(20)
print(top_20_bodegas_1.to_frame().T) # Veces que se menciona cada bodega del top 20.
print(top_20_bodegas_1/ top_20_bodegas_1.sum() * 100)  # Proporci√≥n porcentual

# Datos
labels = top_20_bodegas_1.index
sizes = top_20_bodegas_1.values
colors = plt.cm.cool(np.linspace(0, 1, len(labels)))

# Crear gr√°fico con plt.pie() (devuelve wedges, texts, autotexts)
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    colors=colors,
    startangle= 90,
    counterclock=False,
    pctdistance=0.8,
    textprops={'fontsize': 8},
    wedgeprops={'edgecolor': 'white', 'linewidth': 0.5}
)

# Personalizar autotexts
plt.setp(autotexts, size=7, weight='bold', color='white')

# A√±adir t√≠tulo
plt.title('Las 20 bodegas mas mencionadas y su proporci√≥n', fontsize=14, pad=20, weight='bold')

# Mostrar gr√°fico
plt.tight_layout()
plt.axis('equal')
plt.show()

# Considerando la suma total de conteo de todas las bodegas, la proporcion de las mejores 20 bodegas se reduce como sigue.
top_20_bodegas_2 = df['winery'].value_counts()
print(top_20_bodegas_2.sum())

import pandas as pd
import matplotlib.pyplot as plt

# 1. Obtener datos b√°sicos
top_20_bodegas_2 = df.groupby('winery')['country'].first().loc[df['winery'].value_counts().head(20).index]
proporciones = (df['winery'].value_counts(normalize=True).head(20) * 100)

# 2. Crear DataFrame combinado
resultado = pd.DataFrame({
    'Bodega': proporciones.index,
    'Pa√≠s': top_20_bodegas_2.values,
    'Proporci√≥n (%)': proporciones.round(2).values
})

# 3. Ordenar por proporci√≥n (opcional)
resultado = resultado.sort_values('Proporci√≥n (%)', ascending=True)

# 4. Crear gr√°fico de barras horizontal
plt.figure(figsize=(12, 8))
bars = plt.barh(
    resultado['Bodega'] + ' (' + resultado['Pa√≠s'] + ')',  # Leyenda combinada
    resultado['Proporci√≥n (%)'],
    color=plt.cm.tab20c.colors  # Paleta de colores
)

# 5. A√±adir etiquetas y formato
plt.xlabel('Proporci√≥n (%)', fontsize=12)
plt.title('Top 20 bodegas m√°s mencionadas por pa√≠s y proporci√≥n', fontsize=14, pad=20)
plt.grid(axis='x', linestyle='--', alpha= 0.7)

# 6. A√±adir valores encima de cada barra
for bar in bars:
    width = bar.get_width()
    plt.text(width, bar.get_y() + bar.get_height()/2, f'{width:.2f}%',
             va='center', fontsize=9)

plt.tight_layout()
plt.show()

"""### __Vamos ahora a construir una nueva tabla de informaci√≥n__

#### &#9758; Construye una tabla que muestre pa√≠s, variedad de uva, bodega, y valores de puntuaci√≥n y precio.
- Considera las 10 variedades de uva y las 20 bodegas m√°s importantes.
- Haz una tabla con estos datos y s√≥lo los valores de pa√≠s, bodega, variedad, puntuaci√≥n y precio correspondientes.
- Agrega una columna con el valor de puntos/precio
- Cambia el nombre de la bodega para que √©ste incluya su pa√≠s de origen.
- Ordena los datos por nombre de pa√≠s, variedad y bodega (orden ascendente).
"""

import pandas as pd

#top_variedades = df['variety'].value_counts().head(10)
#top_bodegas = df['winery'].value_counts().head(20)


# 1. Filtrar las 10 variedades y 20 bodegas m√°s frecuentes
top_variedades = df['variety'].value_counts().head(10).index
top_bodegas = df['winery'].value_counts().head(20).index

# 2. Filtrar el DataFrame original
df_filtrado = df[
    (df['variety'].isin(top_variedades)) &
    (df['winery'].isin(top_bodegas))
][['country', 'winery', 'variety', 'points', 'price']].copy()

# 3. Calcular puntos/precio y redondear
df_filtrado['puntos/precio'] = (df_filtrado['points'] / df_filtrado['price']).round(2)

# 4. Modificar el nombre de la bodega (agregar pa√≠s)
df_filtrado['bodega_pais'] = df_filtrado['winery'] + ' (' + df_filtrado['country'] + ')'

# 5. Ordenar y seleccionar columnas finales
tabla_final = df_filtrado.sort_values(
    by=['country', 'variety', 'winery'],
    ascending=True
)[['country', 'bodega_pais', 'variety', 'points', 'price', 'puntos/precio']]

# Mostrar tabla
#print(tabla_final.to_string(index=False)) #.to_string() --> Pandas convierte el DataFrame en string (texto plano). Index= False, elimina la columna de indices
tabla_final.head(20)

"""#### &#9758; Observa la relaci√≥n puntos-precio por pa√≠s"""

print("Pa√≠ses disponibles:", tabla_final['country'].unique()) # No entiendo por que sale ese NaN en paises.

p_v = tabla_final

sns.relplot(x="points", y="price", hue="country", col='country', col_wrap=5, kind="line", data=p_v)

p_v_italy = p_v[p_v['country'] == 'Italy']

p_v.isna().sum(axis=0).to_frame().T

"""#### &#9758; Observa las distribuciones por pares en funci√≥n de la variedad de uva."""

sns.pairplot(p_v, hue="variety", height=3,palette='rocket')

"""#### &#9758; Observa las distribuciones por pares en funci√≥n del pa√≠s."""

#TU CODIGO
sns.pairplot(p_v, hue="country",height=3,palette='rocket')

"""#### &#9758; Observa las distribuciones por pares en funci√≥n de la bodega."""

#TU CODIGO
sns.pairplot(p_v, hue='bodega_pais', height=3,palette='rocket')

"""#### &#9758; Observa las distribuciones (scatter) de precio por variedad de uva."""

#TU CODIGO
import matplotlib.pyplot as plt

# Crear el gr√°fico
plt.figure(figsize=(12, 6))

# Scatter plot por variedad
for variety in p_v["variety"].unique():
    subset = p_v[p_v["variety"] == variety]
    plt.scatter(
        subset["price"],
        subset["variety"],
        label=variety,
        alpha=0.6
    )

# Personalizar
plt.title("Precio vs Variedad de Uva")
plt.xlabel("Precio (USD)")
plt.ylabel("Variedad")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

plt.show()

"""#### &#9758; Observa las distribuciones (scatter) de precio por bodega."""

#TU CODIGO

import matplotlib.pyplot as plt

# Crear el gr√°fico
plt.figure(figsize=(12, 6))

# Scatter plot por variedad
for bodega in p_v["bodega_pais"].unique():
    subset = p_v[p_v["bodega_pais"] == bodega]
    plt.scatter(
        subset["price"],
        subset["bodega_pais"],
        label=bodega,
        alpha=0.6
    )

# Personalizar
plt.title("Precio vs Mejor Bodega")
plt.xlabel("Precio (USD)")
plt.ylabel("Variedad")
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

plt.show()

"""#### &#9758; Observa las distribuciones (scatter) de puntos/precio por bodega."""

import seaborn as sns
import matplotlib.pyplot as plt

# Ordenar bodegas por puntaje/precio (opcional)
top_bodegas = p_v.groupby("bodega_pais")["puntos/precio"].mean().sort_values(ascending=False).head(10).index

# Filtrar solo las top bodegas
p_v_filtered = p_v[p_v["bodega_pais"].isin(top_bodegas)]

# Crear el gr√°fico con seaborn (maneja mejor categor√≠as)
plt.figure(figsize=(12, 6))
sns.stripplot(
    data=p_v_filtered,
    x="bodega_pais",
    y="puntos/precio",
    hue="puntos/precio",  # Opcional: colorear por el valor
    palette="viridis",
    alpha=0.7,
    jitter=True  # Evita superposici√≥n de puntos
)

# Reducir tama√±o de etiquetas del eje x
plt.xticks(
    rotation=45,           # Rotar 45 grados
    ha='right',            # Alinear a la derecha
    fontsize=8            # Tama√±o de fuente peque√±o
)

# Ajustes adicionales
plt.title("Puntos/Precio vs Bodega (Top 10)", fontsize=14)
plt.xlabel("Bodega", fontsize=10)
plt.ylabel("Puntos/Precio", fontsize=10)
plt.tight_layout()  # Ajustar espacio para evitar cortes
plt.legend(bbox_to_anchor=(1.1, 1.03), loc='upper right')
plt.show()

"""#### &#9758; Observa las distribuciones (scatter) de puntos/precio por pa√≠s."""

#TU CODIGO
import seaborn as sns
import matplotlib.pyplot as plt

# Ordenar bodegas por puntaje/precio (opcional)
top_bodegas_1 = p_v.groupby("country")["puntos/precio"].mean().sort_values(ascending=False).head(10).index

# Filtrar solo las top bodegas
p_v_filtered = p_v[p_v["country"].isin(top_bodegas_1)]

# Crear el gr√°fico con seaborn (maneja mejor categor√≠as)
plt.figure(figsize=(12, 6))
sns.stripplot(
    data=p_v_filtered,
    x="country",
    y="puntos/precio",
    hue="puntos/precio",  # Opcional: colorear por el valor
    palette="viridis",
    alpha=0.7,
    jitter=True  # Evita superposici√≥n de puntos
)

# Reducir tama√±o de etiquetas del eje x
plt.xticks(
    rotation=45,           # Rotar 45 grados
    ha='right',            # Alinear a la derecha
    fontsize=8            # Tama√±o de fuente peque√±o
)

# Ajustes adicionales
plt.title("Puntos/Precio vs Country (Top 10)", fontsize=14)
plt.xlabel("Country", fontsize=10)
plt.ylabel("Puntos/Precio", fontsize=10)
plt.tight_layout()  # Ajustar espacio para evitar cortes
plt.legend(bbox_to_anchor=(1.1, 1.03), loc='upper right')
plt.show()

"""### __Agrega los datos de M√©xico a esta √∫ltima tabla de informaci√≥n__

#### &#9758; Une la tabla de vinosMX a la tabla p_v
- Aseg√∫rate de __no agregar__ la columna de descripci√≥n
"""

vinosMX_1 = vinosMX
vinosMX_1.head(2)

vinosMX_1.drop(columns=["description"], inplace=True)
vinosMX_1.head(2)

print("Columnas en p_v:", p_v.columns.tolist())
print("Columnas en vinosMX:", vinosMX_1.columns.tolist())

p_v = p_v.rename(columns={"bodega_pais": "winery"})

#TU CODIGO
df3 = pd.concat([p_v, vinosMX], axis=0, ignore_index= True)
df3.head(3)

"""#### &#9758; Calcula los valores de points/price para los vinos de M√©xico
- TIP: Usa el m√©todo apply sobre `df3[['points','price','points/price']]`
"""

# TU CODIGO
import pandas as pd

# Solo vinos de M√©xico
df_mexico = df3[df3['country'] == 'Mexico'].copy()

# Calcular points/price con apply()
df_mexico['points/price'] = df_mexico.apply(
    lambda row: row['points'] / row['price'] if row['price'] != 0 else None,  # Evitar divisi√≥n por cero
    axis=1)

# Mostrar las columnas relevantes
resultado = df_mexico[['points', 'price', 'points/price']]
print(resultado.head())

"""#### &#9758; Observa la relaci√≥n puntos-precio por pa√≠s"""

sns.relplot(x="points", y="price", hue="country", col='country',kind="line", data=df3)

"""#### &#9758; Observa las distribuciones por pares en funci√≥n del pa√≠s.
- Construye una tabla auxiliar "mx_top", donde los datos de M√©xico (en df3) aparezcan al final de la tabla mx_top.
"""

# 1. Filtrar los datos de M√©xico y el resto de pa√≠ses
df_mexico = df3[df3['country'] == 'Mexico'].copy()  # Datos de M√©xico
df_otros = df3[df3['country'] != 'Mexico'].copy()   # Datos de otros pa√≠ses

# 2. Concatenar: primero otros pa√≠ses, luego M√©xico
mx_top = pd.concat([df_otros, df_mexico], axis=0, ignore_index=True)

# 3. Mostrar resultados (opcional)
print(mx_top[['country', 'winery', 'points', 'price']].tail())  # Ver √∫ltimos registros (M√©xico)


sns.pairplot(mx_top, hue="country",height=3,palette='bright')

"""#### &#9758; Observa las distribuciones (scatter) de puntos por pa√≠s."""

plt.figure(figsize=(10,5))
sns.stripplot(x="country", y="points", data=df3,dodge=True,palette='deep',marker='*',size=8)
plt.xticks(rotation= 45, ha="right")

"""#### &#9758; Observa las distribuciones (scatter) de precios por bodega."""

plt.figure(figsize=(10,5))
sns.stripplot(x="winery", y="price", data=df3,dodge=True,palette='rocket',marker='*',size=8)
plt.xticks(rotation= 45, ha="right")

"""#### &#9758; Observa las distribuciones (scatter) de puntos/precio por bodega.
- Dibuja una l√≠nea que marque el promedio de todos los datos
- Dibuja marcas ubicadando los valores promedio por cada bodega (TIP: usa `groupby` sobre pa√≠s y bodega para calcular primero los valores promedio)
"""

# Verifica valores nulos o enmascarados
print("Valores nulos en 'winery':", df3['winery'].isna().sum())
print("Valores nulos en 'points/price':", df3['puntos/precio'].isna().sum())

# Elimina filas con valores nulos (si es apropiado)
df3_clean = df3.dropna(subset=['winery', 'puntos/precio'])

# Convierte a string si el eje X es categ√≥rico
df3['winery'] = df3['winery'].astype(str)

# Reemplaza NaN por 0 o un valor m√≠nimo en el eje Y (si es num√©rico)
df3['puntos/precio'] = df3['puntos/precio'].fillna(0)

sns.boxplot(
    data=df3_clean,
    x='country',        # Eje categ√≥rico
    y='puntos/precio',   # Eje num√©rico
    palette='viridis'
)

"""#### &#9758; Si consideramos la proporci√≥n de los pa√≠ses con mejor relaci√≥n puntos/precio, ¬øc√≥mo queda M√©xico?
- Usa un gr√°fico de pastel
"""

import matplotlib.pyplot as plt
import numpy as np

proporcion_pais = df3.groupby('country')['puntos/precio'].mean().sort_values(ascending=False)
top_paises = proporcion_pais.head(10)

# Datos
labels = top_paises.index
sizes = top_paises.values
colors = plt.cm.rainbow(np.linspace(0, 1, len(labels)))

# Crear gr√°fico con plt.pie() (devuelve wedges, texts, autotexts)
wedges, texts, autotexts = plt.pie(
    sizes,
    labels=labels,
    autopct='%1.2f%%',
    colors=colors,
    startangle= 90,
    pctdistance=0.9,
    textprops={'fontsize': 7},
    wedgeprops={'edgecolor': 'white', 'linewidth': 0.5}
)

# Personalizar autotexts (ahora la variable existe)
plt.setp(autotexts, size=6, weight='bold', color='white')

# A√±adir t√≠tulo
plt.title('Top 20 pa√≠ses por puntuaci√≥n promedio', fontsize=14, pad=20, weight='bold')

# Mostrar gr√°fico
plt.tight_layout()
plt.axis('equal')
plt.show()